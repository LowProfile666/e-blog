/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80030
 Source Host           : localhost:3306
 Source Schema         : ssm

 Target Server Type    : MySQL
 Target Server Version : 80030
 File Encoding         : 65001

 Date: 27/09/2024 16:18:13
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `photoPath` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `createTime` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `updateTime` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `deleteFlag` int NOT NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES (16, '第4444次实验', '', '/upload/activity.jpg', '[object Object]', '', '2024/6/30 11:31:30', NULL, 0);
INSERT INTO `articles` VALUES (17, '第五次实验了', '这是第五次实验，实时修改', '/static/images/img1.png', '[object Object]', '', '2024/6/30 11:41:34', NULL, 0);
INSERT INTO `articles` VALUES (24, 'MyBatis总结笔记', '总结了MyBatis的原理，以及如何使用', '/static/images/img1.png', 'note', '# 使用\r\n\r\n## 1 引入依赖\r\n\r\n1、在pom.xml文件中引入mybatis的依赖和mysql的依赖：\r\n\r\n```xml\r\n<!--mybatis核心依赖-->\r\n<dependency>\r\n  <groupId>org.mybatis</groupId>\r\n  <artifactId>mybatis</artifactId>\r\n  <version>3.5.10</version>\r\n</dependency>\r\n<!--mysql驱动依赖-->\r\n<dependency>\r\n  <groupId>mysql</groupId>\r\n  <artifactId>mysql-connector-java</artifactId>\r\n  <version>8.0.30</version>\r\n</dependency>\r\n```\r\n\r\n## 2 创建配置文件\r\n\r\n2、在resources目录下创建mybatis的配置文件mybatis-config.xml：\r\n\r\n+ 放到resources目录下的文件相当于放到了类的根目录下。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/powernode\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"root\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n    <mappers>\r\n        <!--sql映射文件创建好之后，需要将该文件路径配置到这里-->\r\n        <mapper resource=\"\"/>\r\n    </mappers>\r\n</configuration>\r\n```\r\n\r\n+ 注意1：mybatis核心配置文件的文件名不一定是mybatis-config.xml，可以是其它名字。\r\n+ 注意2：mybatis核心配置文件存放的位置也可以随意。\r\n\r\n3、在resources目录下创建mapper的配置文件，比如CarMapper.xml：\r\n\r\n+ 在这个配置文件中编写SQL语句\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!--namespace先随意写一个-->\r\n<mapper namespace=\"car\">\r\n    <!--insert sql：保存一个汽车信息-->\r\n    <insert id=\"insertCar\">\r\n        insert into t_car\r\n            (id,car_num,brand,guide_price,produce_time,car_type) \r\n        values\r\n            (null,\'102\',\'丰田mirai\',40.30,\'2014-10-05\',\'氢能源\')\r\n    </insert>\r\n</mapper>\r\n```\r\n\r\n+ 注意1：sql语句最后结尾可以不写“;”\r\n\r\n+ 注意2：CarMapper.xml文件的名字不是固定的。可以使用其它名字。\r\n\r\n+ 注意3：CarMapper.xml文件的位置也是随意的。\r\n\r\n4、将创建的mapper配置文件配置到mybatis核心配置文件中：\r\n\r\n```xml\r\n<mappers>\r\n    <!--sql映射文件创建好之后，需要将该文件路径配置到这里-->\r\n    <mapper resource=\"CarMapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n+ 使用resource属性，这种方式是从类路径当中加载资源\r\n\r\n## 3 编写代码\r\n\r\n5、编写代码\r\n\r\nmybatis中执行sql语句的对象是SqlSession对象，SqlSession对象通过SqlSessionFactory对象来获得，SqlSessionFactory对象通过SqlSessionFactoryBuilder对象的build方法创建。\r\n\r\n所以获取一个执行sql语句的SqlSession对象：\r\n\r\n```java\r\n// 1. 创建SqlSessionFactoryBuilder对象\r\nSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\r\n// 2. 创建SqlSessionFactory对象\r\nInputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatis-config.xml\");\r\nSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\r\n// 3. 创建SqlSession对象\r\nSqlSession sqlSession = sqlSessionFactory.openSession();\r\n```\r\n\r\n+ 在创建SqlSessionFactory对象时，需要一个输入流，这个输入流指向mybatis的核心配置文件mybatis-config.xml\r\n\r\n+ 而mybatis核心配置文件的名字就是在这里使用，所以可以随意命名；位置也是可以随意，只要这个输入流能找到。\r\n\r\n+ mabatis有一个Resources类，提供了一个方法，从类路径当中获取资源：\r\n\r\n  ```java\r\n  InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\r\n  ```\r\n\r\n通过这个SqlSession对象执行sql语句：\r\n\r\n```java\r\nsqlSession.insert(\"insertCar\");\r\nsqlSession.commit();\r\nsqlSession.close();\r\n```\r\n\r\n+ 执行了一句插入语句， 这个\"insertCar\"必须是sql语句的id，这个sql语句是写在CarMapper.xml中的\r\n+ mybatis默认采用的事务管理器是JDBC，默认是不提交的，需要手动提交。\r\n\r\n# 事务\r\n\r\n mbatis中的事务是需要自己手动提交的：\r\n\r\n```java\r\nsqlSession.commit();\r\n```\r\n\r\n在 mybatis 中，提供了两种事务管理机制：\r\n\r\n第一种：JDBC事务管理器：\r\n\r\nmybatis 框架自己管理事务，自己采用原生的 JDBC 代码去管理事务：\r\n\r\n+ `conn.setAutoCommit(false)`，开启事务\r\n+ `conn.commit()`：提交事务\r\n\r\n第二种：MANAGED事务管理器：\r\n\r\nmybatis 不再负责事务的管理了，事务管理交给其他容器来负责，例如：Spring。\r\n\r\n在 mybatis-config.xml 文件中，可以通过以下的配置来进行 mybatis 的事务管理：\r\n\r\n```xml\r\n<transactionManager type=\"JDBC\"/>\r\n```\r\n\r\n+ type 属性的值有两个（不区分大小写）：\r\n  + JDBC（jdbc）\r\n  + MANAGED（managed）\r\n\r\n# 使用JUnit\r\n\r\nJUnit是专门做单元测试的组件。\r\n\r\n1、引入依赖：\r\n\r\n```xml\r\n<!-- junit依赖 -->\r\n<dependency>\r\n    <groupId>junit</groupId>\r\n    <artifactId>junit</artifactId>\r\n    <version>4.13.2</version>\r\n    <scope>test</scope>\r\n</dependency>\r\n```\r\n\r\n2、编写单元测试类【测试用例】：\r\n\r\n```java\r\n// 测试用例\r\npublic class CarMapperTest{\r\n    // 测试方法\r\n    @Test\r\n    public void testInsert(){}\r\n    @Test\r\n    public void testUpdate(){}\r\n}\r\n```\r\n\r\n+ 测试用例中每一个测试方法上使用`@Test`注解进行标注。	\r\n\r\n测试用例的名字以及每个测试方法的定义都是有规范的：\r\n\r\n- 测试用例的名字：`XxxTest`\r\n\r\n- 测试方法声明格式：`public void test业务方法名(){}`\r\n\r\n注意：测试方法没有参数列表，没有返回值。\r\n\r\n# 使用logback\r\n\r\nlogback是一个日志框架。\r\n\r\n1、引入依赖：\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>ch.qos.logback</groupId>\r\n  <artifactId>logback-classic</artifactId>\r\n  <version>1.2.11</version>\r\n  <scope>test</scope>\r\n</dependency>\r\n```\r\n\r\n2、创建logback配置文件：\r\n\r\n+ 文件名必须叫做`logback.xml`或`logback-test.xml`，必须放到类路径当中\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<configuration debug=\"false\">\r\n    <!-- 控制台输出 -->\r\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\r\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\r\n        </encoder>\r\n    </appender>\r\n    <!-- 按照每天生成日志文件 -->\r\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\r\n            <!--日志文件输出的文件名-->\r\n            <FileNamePattern>${LOG_HOME}/TestWeb.log.%d{yyyy-MM-dd}.log</FileNamePattern>\r\n            <!--日志文件保留天数-->\r\n            <MaxHistory>30</MaxHistory>\r\n        </rollingPolicy>\r\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\r\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\r\n        </encoder>\r\n        <!--日志文件最大的大小-->\r\n        <triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\">\r\n            <MaxFileSize>100MB</MaxFileSize>\r\n        </triggeringPolicy>\r\n    </appender>\r\n\r\n    <!--mybatis log configure-->\r\n    <logger name=\"com.apache.ibatis\" level=\"TRACE\"/>\r\n    <logger name=\"java.sql.Connection\" level=\"DEBUG\"/>\r\n    <logger name=\"java.sql.Statement\" level=\"DEBUG\"/>\r\n    <logger name=\"java.sql.PreparedStatement\" level=\"DEBUG\"/>\r\n\r\n    <!-- 日志输出级别,logback日志级别包括五个：TRACE < DEBUG < INFO < WARN < ERROR -->\r\n    <root level=\"DEBUG\">\r\n        <appender-ref ref=\"STDOUT\"/>\r\n        <appender-ref ref=\"FILE\"/>\r\n    </root>\r\n\r\n</configuration>\r\n```\r\n\r\n# 给sql语句传值\r\n\r\n## 使用map\r\n\r\n将数据放到一个Map集合中，在sql语句中来使用这个Map集合传值。\r\n\r\nJava测试程序：\r\n\r\n```java\r\npublic class CarMapperTest {\r\n    @Test\r\n    public void testInsertCar(){\r\n        // 准备数据\r\n        Map<String, Object> map = new HashMap<>();\r\n        map.put(\"carNum\", \"103\");\r\n        map.put(\"brand\", \"奔驰E300L\");\r\n        map.put(\"guidePrice\", 50.3);\r\n        map.put(\"produceTime\", \"2020-10-01\");\r\n        map.put(\"carType\", \"燃油车\");\r\n        // 获取SqlSession对象\r\n        SqlSession sqlSession = SqlSessionUtil.openSession();\r\n        // 执行SQL语句（使用map集合给sql语句传递数据）\r\n        int count = sqlSession.insert(\"insertCar\", map);\r\n        System.out.println(\"插入了几条记录：\" + count);\r\n    }\r\n}\r\n```\r\n\r\nsql语句：\r\n\r\n```java\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n\r\n<!--namespace先随便写-->\r\n<mapper namespace=\"car\">\r\n    <insert id=\"insertCar\">\r\n        insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType})\r\n    </insert>\r\n</mapper>\r\n```\r\n\r\n#{} 的里面必须填写map集合的key，不能随便写。\r\n\r\n## 使用pojo\r\n\r\n使用pojo传值时，本质上是调用的pojo的get方法，sql语句中的#{}中必须写get方法的方法名去掉get之后将剩下的单词首字母变小写，例如：getAge对应的是#{age}。\r\n\r\nJava程序：\r\n\r\n```java\r\n@Test\r\npublic void testInsertCarByPOJO(){\r\n    // 创建POJO，封装数据\r\n    Car car = new Car();\r\n    car.setCarNum(\"103\");\r\n    car.setBrand(\"奔驰C200\");\r\n    car.setGuidePrice(33.23);\r\n    car.setProduceTime(\"2020-10-11\");\r\n    car.setCarType(\"燃油车\");\r\n    // 获取SqlSession对象\r\n    SqlSession sqlSession = SqlSessionUtil.openSession();\r\n    // 执行SQL，传数据\r\n    int count = sqlSession.insert(\"insertCarByPOJO\", car);\r\n    System.out.println(\"插入了几条记录\" + count);\r\n}\r\n```\r\n\r\nsql语句：\r\n\r\n```xml\r\n<insert id=\"insertCarByPOJO\">\r\n  <!--#{} 里写的是POJO的get方法去掉get之后的单词首字母小写-->\r\n  insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType})\r\n</insert>\r\n```\r\n\r\n如果没有对应的get方法，会报错。\r\n\r\n## 只有一个占位符\r\n\r\n当sql语句中只有一个#{}时，#{}里面的内容可以随便写。\r\n\r\n# 处理查询结果集\r\n\r\n## 查询返回一个Java对象\r\n\r\n对于一个查询语句来说，需要指定它的“结果类型”或者“结果映射”。\r\n\r\n所以想让mybatis查询之后返回一个Java对象的话，至少要告诉mybatis返回一个什么类型的Java对象，可以在<select>标签中添加resultType属性，用来指定查询要转换的类型：\r\n\r\n```xml\r\n<select id=\"selectCarById\" resultType=\"com.powernode.mybatis.pojo.Car\">\r\n  select * from t_car where id = #{id}\r\n</select>\r\n```\r\n\r\n同时，查询出来的结果集的**列名**必须和Java对象的**属性名**一致，否则对应的属性不会被赋值。\r\n\r\n+ 可以在sql语句中使用as来取别名\r\n\r\n  ```xml\r\n  <select id=\"selectCarById\" resultType=\"com.powernode.mybatis.pojo.Car\">\r\n  select \r\n      id, car_num as carNum, \r\n      brand, \r\n      guide_price as guidePrice, \r\n      produce_time as produceTime, \r\n      car_type as carType \r\n  from \r\n      t_car \r\n  where \r\n      id = #{id}\r\n  </select>\r\n  ```\r\n\r\n## 查询返回一个List集合\r\n\r\n还是要用resultType属性来指定List集合中的数据类型，而不是指定List类型。\r\n\r\n```xml\r\n<select id=\"selectCarAll\" resultType=\"com.powernode.mybatis.pojo.Car\">\r\nselect \r\n    id, car_num as carNum, \r\n    brand, \r\n    guide_price as guidePrice, \r\n    produce_time as produceTime, \r\n    car_type as carType \r\nfrom \r\n    t_car \r\n</select>\r\n```\r\n\r\n# SqlMapper的namespace\r\n\r\n在SQL Mapper配置文件中<mapper>标签的namespace属性可以翻译为命名空间，这个命名空间主要是为了防止sqlId冲突的。\r\n\r\n如果有两个mapper配置文件，其中的有sql语句的id一样，那么就需要通过namespace来区分，否则会报错。\r\n\r\n比如有一个CarMapper2.xml配置文件，他的命名空间是car2：\r\n\r\n```xml\r\n<mapper namespace=\"car2\">\r\n    <select id=\"selectCarAll\" resultType=\"com.powernode.mybatis.pojo.Car\">\r\n    select \r\n        id, car_num as carNum, \r\n        brand, \r\n        guide_price as guidePrice, \r\n        produce_time as produceTime, \r\n        car_type as carType \r\n    from \r\n        t_car \r\n    </select>\r\n</mapper>\r\n```\r\n\r\n那么在Java程序中使用car2的selectAll语句：\r\n\r\n```java\r\nList<Object> cars = sqlSession.selectList(\"car2.selectCarAll\");\r\n```\r\n\r\n# #{}和${}\r\n\r\n\\#{}：先编译sql语句，再给占位符传值，底层是PreparedStatement实现。可以防止sql注入，比较常用。\r\n\r\n${}：先进行sql语句拼接，然后再编译sql语句，底层是Statement实现。存在sql注入现象。只有在需要进行sql语句关键字拼接的情况下才会用到。\r\n\r\n# 不写mapper实现类\r\n\r\nmybatis可以自己实现mapper接口的实现类，但是需要注意，mapper.xml文件中的namespace必须是和mapper接口名一致，id必须和接口中的方法名一致。\r\n\r\n# 别名\r\n\r\nmapper.xml文件中的resultType属性用来指定查询结果集的封装类型，可以起别名。\r\n\r\n第一种方式：\r\n\r\n```xml\r\n<typeAliases>\r\n  <typeAlias type=\"com.powernode.mybatis.pojo.Car\" alias=\"Car\"/>\r\n</typeAliases>\r\n```\r\n\r\n- type属性：指定给哪个类起别名\r\n- alias属性：别名。\r\n  -  alias属性不是必须的，如果缺省的话，type属性指定的类型名的简类名作为别名。\r\n  -  alias是大小写不敏感的。也就是说假设alias=\"Car\"，再用的时候，可以CAR，也可以car，也可以Car，都行。\r\n\r\n第二种方式：\r\n\r\n```xml\r\n<typeAliases>\r\n  <package name=\"com.powernode.mybatis.pojo\"/>\r\n</typeAliases>\r\n```\r\n\r\n只需要指定包名，该包下的所有类都自动起别名，别名就是简类名。并且别名不区分大小写。\r\n\r\n# 结果映射\r\n\r\n查询结果的列名和java对象的属性名对应不上怎么办？\r\n\r\n- 第一种方式：as 给列起别名\r\n- 第二种方式：使用resultMap进行结果映射\r\n- 第三种方式：是否开启驼峰命名自动映射（配置settings）\r\n\r\n使用resultMap进行结果映射：\r\n\r\n```xml\r\n<resultMap id=\"carResultMap\" type=\"car\">\r\n  <!--对象的唯一标识，官方解释是：为了提高mybatis的性能。建议写上。-->\r\n  <id property=\"id\" column=\"id\"/>\r\n  <result property=\"carNum\" column=\"car_num\"/>\r\n  <!--当属性名和数据库列名一致时，可以省略。但建议都写上。-->\r\n  <!--javaType用来指定属性类型。jdbcType用来指定列类型。一般可以省略。-->\r\n  <result property=\"brand\" column=\"brand\" javaType=\"string\" jdbcType=\"VARCHAR\"/>\r\n  <result property=\"guidePrice\" column=\"guide_price\"/>\r\n  <result property=\"produceTime\" column=\"produce_time\"/>\r\n  <result property=\"carType\" column=\"car_type\"/>\r\n</resultMap>\r\n\r\n<!--resultMap属性的值必须和resultMap标签中id属性值一致，用来指定使用哪个结果集 。-->\r\n<select id=\"selectAllByResultMap\" resultMap=\"carResultMap\">\r\n  select * from t_car\r\n</select>\r\n```\r\n\r\n驼峰命名自动映射：\r\n\r\n```xml\r\n<!--放在properties标签后面-->\r\n<settings>\r\n  <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n使用这种方式的前提是：属性名遵循Java的命名规范，数据库表的列名遵循SQL的命名规范。\r\n\r\n+ Java命名规范：首字母小写，后面每个单词首字母大写，遵循驼峰命名方式。\r\n+ SQL命名规范：全部小写，单词之间采用下划线分割。', '2024/6/30 20:16:16', NULL, 0);
INSERT INTO `articles` VALUES (25, 'Spring6笔记', '总结了Spring6的注解式开发的关键知识点', '/static/images/img1.png', 'note', '# 需要的依赖\r\n\r\n+ spring-context\r\n\r\n# 注解式开发\r\n\r\n## bean的注解\r\n\r\n控制器类上使用：@Controller\r\n\r\nservice类上使用：@Service\r\n\r\ndao类上使用：@Repository\r\n\r\n@Controller、@Service、@Repository这三个注解都是@Component注解的别名。\r\n\r\n他们都是只有一个value属性。value属性用来指定bean的id，也就是bean的名字。\r\n\r\n```java\r\n@Component(\"vipBean\")\r\npublic class Vip {\r\n}\r\n```\r\n\r\n如果不指定value的值，spring会自动默认名字是类名首字母小写。\r\n\r\n```java\r\n@Component\r\npublic class BankDao {\r\n}\r\n```\r\n\r\n这个BankDao的bean的名字为：bankDao。\r\n\r\n## 包扫描\r\n\r\n需要在spring.xml文件中指定spring要扫描的包：\r\n\r\n```xml\r\n<context:component-scan base-package=\"com.zsm.spring6.bean\"/>\r\n```\r\n\r\n## 注入的注解\r\n\r\n给Bean属性赋值需要用到这些注解：\r\n\r\n- @Value\r\n- @Autowired\r\n- @Qualifier\r\n- @Resource\r\n\r\n### @Value\r\n\r\n可以使用在属性上\r\n\r\n```java\r\n@Component\r\npublic class User {\r\n    @Value(value = \"zhangsan\")\r\n    private String name;\r\n    @Value(\"20\")\r\n    private int age;\r\n}\r\n```\r\n\r\n可以使用在set方法上\r\n\r\n```java\r\n@Component\r\npublic class User {\r\n    private String name;\r\n    private int age;\r\n\r\n    @Value(\"李四\")\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Value(\"30\")\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n可以使用在构造方法的参数上\r\n\r\n```java\r\n@Component\r\npublic class User {\r\n    private String name;\r\n    private int age;\r\n\r\n    public User(@Value(\"隔壁老王\") String name, @Value(\"33\") int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n### @Autowired\r\n\r\n用来注入非简单类型。单独使用该注解，默认是根据类型装配。\r\n\r\n使用在属性上：\r\n\r\n```java\r\n@Service // 纳入bean管理\r\npublic class UserService {\r\n    // @Autowired注解使用的时候，不需要指定任何属性，直接使用这个注解即可\r\n    // 这个注解的作用是根据类型byType进行自动装配\r\n    @Autowired // 在属性上注入\r\n    private UserDao userDao;\r\n    \r\n    // 没有提供构造方法和setter方法。\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n使用在set方法上：\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    private UserDao userDao;\r\n\r\n    @Autowired\r\n    public void setUserDao(UserDao userDao) {\r\n        this.userDao = userDao;\r\n    }\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n使用在构造方法的参数上：\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    private UserDao userDao;\r\n\r\n    public UserService(@Autowired UserDao userDao) {\r\n        this.userDao = userDao;\r\n    }\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n@Autowired还可以省略不写，只有当：构造方法只有一个，且构造方法上的参数和属性能够对应的时候\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    private UserDao userDao;\r\n\r\n    public UserService(UserDao userDao) {\r\n        this.userDao = userDao;\r\n    }\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n### @Qualifier\r\n\r\n当一个接口有两个不同的实现类时，就不能使用通过类型自动装配了，就需要通过名字来自动装配。\r\n\r\n@Autowired注解和@Qualifier注解联合起来才可以根据名称进行装配，在@Qualifier注解中指定Bean名称。\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    private UserDao userDao;\r\n\r\n    @Autowired\r\n    @Qualifier(\"userDaoForOracle\") // 这个是bean的名字。\r\n    public void setUserDao(UserDao userDao) {\r\n        this.userDao = userDao;\r\n    }\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n### @Resource\r\n\r\n该注解也是用来注入非简单类型的。这是标准注解。\r\n\r\n@Resource注解是JDK包中的，@Autowired注解是Spring包中的。\r\n\r\n@Resource注解默认根据名称装配（byName），未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配（byType）。\r\n\r\n该注解能用在属性上：\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    // @Resource(name = \"xyz\")\r\n    @Resource  // 这个name默认是userDao\r\n    private UserDao userDao;\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n用在set方法上：set方法的方法名去掉set后，首字母小写就是name\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    private UserDao userDao;\r\n\r\n    // @Resource(name = \"userDaoForMySQL\")\r\n    @Resource  // userDao就是name\r\n    public void setUserDao(UserDao userDao) {\r\n        this.userDao = userDao;\r\n    }\r\n\r\n    public void save(){\r\n        userDao.insert();\r\n    }\r\n}\r\n```\r\n\r\n', '2024/6/30 20:17:36', NULL, 0);
INSERT INTO `articles` VALUES (26, 'Spring6整合MyBatis', '整合的原理和配置文件的模板', '/static/images/img1.png', 'note', '主要问题就是将Mybatis中需要用到的一些对象交给Spring来管理。\r\n\r\n首先是要引入spring和mybatis需要的依赖：\r\n\r\n+ Spring需要的依赖：spring-context\r\n+ Mybatis需要的依赖：mybatis、mysql-connector-java、druid\r\n+ spring和mybatis集成依赖：mybatis-spring、spring-jdbc\r\n+ 测试依赖：junit\r\n+ 日志依赖：logback-classic\r\n\r\nMybatis中操作数据库的对象是SqlSession对象，所以要用Spring来管理SqlSession对象。在Mybatis中，SqlSession这个对象由SalSessionFactory对象创建，而SqlSessionFactory这个对象又是由SqlSessionFactoryBuilder对象创建。\r\n\r\nMybatis中获取SqlSession对象是这样的：\r\n\r\n```java\r\nSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\r\nSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(\"mybatis-config.xml\"));\r\nSqlSession sqlSession = sqlSessionFactory.openSession(true);\r\n```\r\n\r\nMybatis中SqlSession对象操作的是SqlMapper文件，需要先获取Mapper对象，也就是dao对象，这个dao对象的类不需要自己写，只需要实现接口，然后通过SqlSession对象来创建对应的dao对象：\r\n\r\n```java\r\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n```\r\n\r\n用Spring来整合Mybatis，mybatis的配置文件就可有可无了，大部分配置都被spring的配置文件代替了，之前的mybatis可能有这些配置：\r\n\r\n```xml\r\n<configuration>\r\n    <!--引入外部属性文件-->\r\n    <properties resource=\"jdbc.properties\" />\r\n    <!--起别名-->\r\n    <typeAliases>\r\n        <package name=\"com.zsm.bean\"/>\r\n    </typeAliases>\r\n    <!--配置环境-->\r\n    <environments default=\"dev\">\r\n        <environment id=\"dev\">\r\n            <!--事务管理器-->\r\n            <transactionManager type=\"JDBC\" />\r\n            <!--数据源-->\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n                <property name=\"url\" value=\"${jdbc.url}\"/>\r\n                <property name=\"username\" value=\"${jdbc.username}\"/>\r\n                <property name=\"password\" value=\"${jdbc.password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <!--注册mapper-->\r\n    <mappers>\r\n        <package name=\"com.zsm.mapper\"/>\r\n    </mappers>\r\n</configuration>\r\n```\r\n\r\n在Spring中，可以通过SqlSessionFactoryBean来创建SqlSessionFactory对象，这个SqlSessionFactoryBean类在mybatis-spring依赖中。\r\n\r\n在spring配置文件中，需要定义mybatis中的数据源、SqlSessionFactoryBean（用来创建SqlSession对象）、mapper扫描器：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <!--包扫描-->\r\n    <context:component-scan base-package=\"com.zsm\" />\r\n    <!--引入外部属性文件，注意路径-->\r\n    <context:property-placeholder location=\"classpath:jdbc.properties\" />\r\n    <!--数据源-->\r\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\r\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\r\n        <property name=\"url\" value=\"${jdbc.url}\"/>\r\n        <property name=\"username\" value=\"${jdbc.username}\"/>\r\n        <property name=\"password\" value=\"${jdbc.password}\"/>\r\n    </bean>\r\n    <!--SqlSessionFactoryBean-->\r\n    <bean class=\"org.mybatis.spring.SqlSessionFactoryBean\" >\r\n        <!--起别名-->\r\n        <property name=\"typeAliasesPackage\" value=\"com.zsm.bean\" />\r\n        <!--注册数据源-->\r\n        <property name=\"dataSource\" ref=\"dataSource\" />\r\n    </bean>\r\n    <!--包扫描器-->\r\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n        <property name=\"basePackage\" value=\"com.zsm.mapper\" />\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n这样就可以不需要mybatis-config配置文件了。\r\n\r\n![image-20240627094052726](https://gitee.com/LowProfile666/image-bed/raw/master/img/202406270940819.png)\r\n\r\n测试程序：\r\n\r\n```java\r\n@Test\r\npublic void testGetUser() {\r\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\");\r\n    UserService userService = applicationContext.getBean(\"userService\", UserService.class);\r\n    User zsm = userService.getUser(\"zsm\");\r\n    System.out.println(zsm);\r\n}\r\n```\r\n\r\n', '2024/6/30 20:18:37', NULL, 0);
INSERT INTO `articles` VALUES (27, 'SpringMVC总结笔记', '总结了SpringMVC的注解开发的常用知识点', '/upload/default.jpg', 'note', '发送请求到DispatcherServlet，根据请求路径将请求分发到某个控制器方法上，控制器方法返回一个页面或数据。\r\n\r\n# 需要的依赖\r\n\r\n+ spring-webmvc\r\n+ jakarta.servlet-api\r\n+ thymeleaf-spring6\r\n\r\n# RequesMapping\r\n\r\n将指定 URL 的请求绑定到一个特定的方法或类上，从而实现对请求的处理和响应。\r\n\r\n使用位置：\r\n\r\n+ 类\r\n\r\n+ 方法\r\n\r\n  ```java\r\n  @Controller\r\n  @RequestMapping(\"/user\")\r\n  public class UserController {\r\n      @RequestMapping(\"/detail\")\r\n      public String toDetail(){\r\n          return \"/user/detail\";\r\n      }\r\n  }\r\n  ```\r\n\r\n表示路径的属性：这两个属性都是一样的，都是数组，随便写哪个都可以\r\n\r\n+ value\r\n+ path\r\n\r\n可以支持路径模糊匹配：\r\n\r\n+ ?，代表任意一个字符：不能匹配 / 和 ？\r\n+ *，代表0到N个任意字符：不能匹配 /\r\n+ **，代表0到N个任意字符，并且路径中可以出现路径分隔符 /：spring6中，只能出现在路径末尾\r\n\r\n表示请求方式的属性：该属性也是一个数组\r\n\r\n+ method\r\n\r\n  ```java\r\n  @RequestMapping(value=\"/login\", method = RequestMethod.POST)\r\n  ```\r\n\r\n表示指定参数的属性：该属性也是一个数组，要求请求参数必须和该数组中要求的所有参数完全一致后，才能映射成功\r\n\r\n+ params\r\n\r\n  表示：请求参数中必须包含 username 和 password，才能与当前标注的方法进行映射。\r\n\r\n  ```java\r\n  @RequestMapping(value=\"/login\", params={\"username\", \"password\"})\r\n  ```\r\n\r\n  表示：请求参数中不能包含username参数，但必须包含password参数，才能与当前标注的方法进行映射。\r\n\r\n  ```java\r\n  @RequestMapping(value=\"/login\", params={\"!username\", \"password\"}) \r\n  ```\r\n\r\n   表示：请求参数中必须包含username参数，并且参数的值必须是admin，另外也必须包含password参数，才能与当前标注的方法进行映射。\r\n\r\n  ```java\r\n  @RequestMapping(value=\"/login\", params={\"username=admin\", \"password\"}) \r\n  ```\r\n\r\n  表示：请求参数中必须包含username参数，但参数的值不能是admin，另外也必须包含password参数，才能与当前标注的方法进行映射。\r\n\r\n  ```java\r\n  @RequestMapping(value=\"/login\", params={\"username!=admin\", \"password\"}) \r\n  ```\r\n\r\n  注意：如果前端提交的参数，和后端要求的请求参数不一致，则出现400错误！！！\r\n\r\n表示指定请求头信息的属性：该属性也是一个数组，用法和params一样\r\n\r\n+ headers\r\n\r\n## 参数\r\n\r\n使用RESTFul风格的请求路径时，可以使用占位符 `{}` 来表示参数。\r\n\r\n```java\r\n@RequestMapping(value=\"/testRESTful/{id}/{username}\")\r\n```\r\n\r\n使用了占位符，就要使用@PathVariable注解标注参数，要在该注解中指定参数的名字（占位符中的名字），它会将数据传到对应的方法参数上：\r\n\r\n```java\r\n@RequestMapping(value=\"/testRESTful/{id}/{username}\")\r\npublic String testRESTful(@PathVariable(\"id\") int id, @PathVariable(\"username\") String username){\r\n    System.out.println(id + \",\" + username);\r\n    return \"testRESTful\";\r\n}\r\n```\r\n\r\n## 衍生RerquetMapping\r\n\r\n+ **PostMaping**：要求前端必须发送post请求\r\n\r\n+ **GetMapping**：要求前端必须发送get请求\r\n+ **PutMapping**：要求前端必须发送put请求\r\n+ **DeleteMapping**：要求前端必须发送delete请求\r\n+ **PatchMapping**：要求前端必须发送patch请求\r\n\r\n# 接收参数\r\n\r\n## RequestParam\r\n\r\n@RequestParam注解作用：将`请求参数`与方法上的`形参`映射。\r\n\r\n```java\r\npublic String register(@RequestParam(\"username\") String username,\r\n                           @RequestParam(\"password\") String password,\r\n                           @RequestParam(\"sex\") Integer sex,\r\n                           @RequestParam(\"hobby\") String[] hobbies,\r\n                           @RequestParam(\"intro\") String intro){}\r\n```\r\n\r\n该注解使用在形参上。该注解会自动做类型转换（将前端传过来的“1”转为1）。\r\n\r\n该注解表示值的属性：这两个属性是一样的，属性值一定是前端传过来的参数名\r\n\r\n+ name\r\n+ value\r\n\r\n表示参数的必要性的属性：没有写时默认为ture，表示必要\r\n\r\n+ required\r\n\r\n  ```java\r\n  @RequestParam(value = \"intro\", required = false)\r\n  ```\r\n\r\n设置默认值的属性：当`没有提供对应的请求参数`或者`请求参数的值是空字符串\"\"`的时候，方法的形参会采用默认值\r\n\r\n+ defaultValue\r\n\r\n  ```java\r\n  @RequestParam(value = \"intro\", required = false, defaultValue = \"hello\")\r\n  ```\r\n\r\n类似的注解：用法都和@RequestParam一样\r\n\r\n+ @RequestHeader：将`请求头信息`映射到`方法的形参`上\r\n+ @CookieValue：将`请求提交的Cookie数据`映射到`方法形参`上\r\n\r\n## 形参\r\n\r\n@RequestParam这个注解可以省略，形参就直接是前端传过来的参数，前提是形参名和传过来的参数名一致。但是在Spring6+中，需要在pom.xml中配置：\r\n\r\n```xml\r\n<build>\r\n    <plugins>\r\n        <plugin>\r\n            <groupId>org.apache.maven.plugins</groupId>\r\n            <artifactId>maven-compiler-plugin</artifactId>\r\n            <version>3.12.1</version>\r\n            <configuration>\r\n                <source>21</source>\r\n                <target>21</target>\r\n                <compilerArgs>\r\n                    <arg>-parameters</arg>\r\n                </compilerArgs>\r\n            </configuration>\r\n        </plugin>\r\n    </plugins>\r\n</build>\r\n```\r\n\r\n## pojo\r\n\r\n前提：`POJO类的属性名`必须和`请求参数的参数名`保持一致，本质上是：POJO类的属性的set方法名去除set后首字母小写\r\n\r\n```java\r\n@PostMapping(\"/register\")\r\npublic String register(User user){\r\n    System.out.println(user);\r\n    return \"success\";\r\n}\r\n```\r\n\r\nSpringMVC看到方法的参数上是一个User对象，就会先通过反射机制拿到User类，创建一个User类对象， 通过前端传过来的参数名推出User类的set方法名，再调用这个set方法给user对象赋值。\r\n\r\n# 三个域对象\r\n\r\n请求域：request\r\n\r\n+ 接口名：HttpServletRequest\r\n+ request对象代表了一次请求。一次请求一个request。\r\n\r\n会话域：session\r\n\r\n+ 接口名：HttpSession\r\n+ session对象代表了一次会话。从打开浏览器开始访问，到最终浏览器关闭，这是一次完整的会话。每个会话session对象都对应一个JSESSIONID，而JSESSIONID生成后以cookie的方式存储在浏览器客户端。浏览器关闭，JSESSIONID失效，会话结束。\r\n\r\n应用域：application\r\n\r\n+ 接口名：ServletContext\r\n+ application对象代表了整个web应用，服务器启动时创建，服务器关闭时销毁。对于一个web应用来说，application对象只有一个。\r\n\r\n都有以下方法：\r\n\r\n```java\r\n// 向域中存储数据\r\nvoid setAttribute(String name, Object obj);\r\n\r\n// 从域中读取数据\r\nObject getAttribute(String name);\r\n\r\n// 删除域中的数据\r\nvoid removeAttribute(String name);\r\n```\r\n\r\n# 转发和重定向\r\n\r\n在Spring MVC中将请求转发到另一个Controller上：\r\n\r\n```java\r\nreturn \"forward:下一个资源的路径\";\r\n```\r\n\r\n重定向：\r\n\r\n```java\r\nreturn \"redirect:下一个资源的路径\";\r\n```\r\n\r\n# RESTFul\r\n\r\nRESTful 的英文全称是 Representational State Transfer（表述性状态转移）。简称REST。\r\n\r\nREST对请求方式的约束是这样的：\r\n\r\n- 查询必须发送GET请求\r\n- 新增必须发送POST请求\r\n- 修改必须发送PUT请求\r\n- 删除必须发送DELETE请求\r\n\r\nREST对URL的约束是这样的：\r\n\r\n- 传统的URL：get请求，/springmvc/getUserById?id=1\r\n- REST风格的URL：get请求，/springmvc/user/1\r\n\r\n- 传统的URL：get请求，/springmvc/deleteUserById?id=1\r\n- REST风格的URL：delete请求, /springmvc/user/1\r\n\r\n# @ResponseBody\r\n\r\n使用 @ResponseBody 注解来启用对应的消息转换器。而这种消息转换器只负责将Controller返回的信息以响应体的形式写入响应协议。\r\n\r\n```java\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @RequestMapping(value = \"/hello\")\r\n    @ResponseBody\r\n    public String hello(){\r\n        // 由于你使用了 @ResponseBody 注解\r\n        // 以下的return语句返回的字符串则不再是“逻辑视图名”了\r\n        // 而是作为响应协议的响应体进行响应。\r\n        return \"hello\";\r\n    }\r\n}\r\n```\r\n\r\n使用@ResponseBody注解可以将返回内容直接响应给浏览器，而不用返回一个页面名字。\r\n\r\n如果想要直接返回一个Java对象，除了使用该注解，还要引入一些依赖，将对象转为json字符串。\r\n\r\n+ 可以使用一些工具类如fastjson将对象转为json字符串返回，返回类型还是字符串：\r\n\r\n  ```java\r\n  @RequestMapping(\"/\")\r\n  @ResponseBody\r\n  public String index() {\r\n      User user = new User(\"zsm\", \"1222\");\r\n      return JSON.toJSONString(user);\r\n  }\r\n  ```\r\n\r\n+ 使用jackson将返回的对象转为json字符串，返回类型还是对象：\r\n\r\n  ```java\r\n  @RequestMapping(\"/\")\r\n  @ResponseBody\r\n  public User index() {\r\n      User user = new User(\"zsm\", \"1222\");\r\n      return user;\r\n  }\r\n  ```\r\n\r\n  需要引入jackson的依赖：\r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-databind</artifactId>\r\n      <version>2.17.0</version>\r\n  </dependency>\r\n  ```\r\n\r\n  需要开启注解驱动，在springmvc.xml中：\r\n\r\n  ```xml\r\n  <mvc:annotation-driven />\r\n  ```\r\n\r\n如果不引入jackson依赖的话，直接返回一个Java对象回去会报错406。\r\n\r\n# @RestController\r\n\r\n这一个注解代表了：@Controller + @ResponseBody。\r\n\r\n@RestController 标注在类上即可。被它标注的Controller中所有的方法上都会自动标注 @ResponseBody\r\n\r\n# @RequestBody\r\n\r\n这个注解的作用是直接将请求体传递给Java程序，在Java程序中可以直接使用一个String类型的变量接收这个请求体的内容，获取到的是原生的请求体，如：username=admin&password=admin。\r\n\r\n这个注解只能出现在方法的参数上。\r\n\r\n而如果前端提交的是一个json格式字符串，而不是原生的格式，想要将该json字符串转成一个Java对象，还是需要使用jackson依赖和开启注解驱动：\r\n\r\n```java\r\n@RequestMapping(\"/a\")\r\n@ResponseBody\r\npublic String index(@RequestBody User user) {\r\n    System.out.println(user);\r\n    return \"ok\";\r\n}\r\n```\r\n\r\n前端提交数据：\r\n\r\n```json\r\n{\r\n    \"username\" : \"zsm\",\r\n    \"password\" : \"123\"\r\n}\r\n```\r\n\r\n如果不使用@RequestBody注解，程序没有问题，只是user对象的属性为null；写了@RequestBody注解，可以正确拿到值。\r\n\r\n# RequestEntity\r\n\r\n这个类的实例封装了整个请求协议：包括请求行、请求头、请求体所有信息。\r\n\r\n出现在控制器方法的参数上，SpringMVC自动创建好，传递给处理器方法的参数上：\r\n\r\n```java\r\n@RequestMapping(\"/send\")\r\n@ResponseBody\r\npublic String send(RequestEntity<User> requestEntity){\r\n    System.out.println(\"请求方式：\" + requestEntity.getMethod());\r\n    System.out.println(\"请求URL：\" + requestEntity.getUrl());\r\n    HttpHeaders headers = requestEntity.getHeaders();\r\n    System.out.println(\"请求的内容类型：\" + headers.getContentType());\r\n    System.out.println(\"请求头：\" + headers);\r\n\r\n    User user = requestEntity.getBody();\r\n    System.out.println(user);\r\n    System.out.println(user.getUsername());\r\n    System.out.println(user.getPassword());\r\n    return \"success\";\r\n}\r\n```\r\n\r\n# ResponseEntity\r\n\r\n用该类的实例可以封装响应协议，包括：状态行、响应头、响应体。也就是说：如果你想定制属于自己的响应协议，可以使用该类。\r\n\r\n```java\r\n@Controller\r\npublic class UserController {\r\n    @GetMapping(\"/users/{id}\")\r\n    // 响应体中的内容是User，所以泛型使用User\r\n    public ResponseEntity<User> getUserById(@PathVariable Long id) {\r\n        User user = userService.getUserById(id);\r\n        if (user == null) {\r\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);\r\n        } else {\r\n            return ResponseEntity.ok(user);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# SpringMVC配置文件\r\n\r\n配置包扫描：\r\n\r\n```xml\r\n<context:component-scan base-package=\"com.zsm.controller\" />\r\n```\r\n\r\n配置视图解析器：\r\n\r\n```xml\r\n<bean id=\"thymeleafViewResolver\" class=\"org.thymeleaf.spring6.view.ThymeleafViewResolver\">\r\n    <property name=\"characterEncoding\" value=\"UTF-8\"/>\r\n    <property name=\"order\" value=\"1\"/>\r\n    <property name=\"templateEngine\">\r\n        <bean class=\"org.thymeleaf.spring6.SpringTemplateEngine\">\r\n            <property name=\"templateResolver\">\r\n                <bean class=\"org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver\">\r\n                    <property name=\"prefix\" value=\"/WEB-INF/templates/\"/>\r\n                    <property name=\"suffix\" value=\".html\"/>\r\n                    <property name=\"templateMode\" value=\"HTML\"/>\r\n                    <property name=\"characterEncoding\" value=\"UTF-8\"/>\r\n                </bean>\r\n            </property>\r\n        </bean>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n配置注解驱动：\r\n\r\n```xml\r\n<mvc:annotation-driven />\r\n```\r\n\r\n+ 用于使用jackson依赖将对象转为json字符串或将json字符串转为对象\r\n+ 用于配置视图解析器\r\n+ 用于配置静态资源\r\n\r\n配置视图解析器：\r\n\r\n```xml\r\n<mvc:view-controller path=\"/如何访问该页面\" view-name=\"对应的逻辑视图名称\" />\r\n```\r\n\r\n+ 需要开启注解驱动\r\n\r\n配置静态资源默认处理Servlet：\r\n\r\n```xml\r\n<mvc:default-servlet-handler>\r\n```\r\n\r\n+ 需要开启注解驱动器\r\n\r\n配置静态资源：\r\n\r\n```xml\r\n<mvc:resources mapping=\"/static/**\" location=\"/static/\" />\r\n```\r\n\r\n+ 凡是请求路径是\"/static/\"开始的，都会去\"/static/\"目录下找该资源。\r\n+ 需要开启注解驱动\r\n\r\n配置自定义异常处理器：\r\n\r\n```xml\r\n<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\r\n    <property name=\"exceptionMappings\">\r\n        <props>\r\n            <!--用来指定出现异常后，跳转的视图：出现Exception异常后，跳转到tip视图-->\r\n            <prop key=\"java.lang.Exception\">tip</prop>\r\n        </props>\r\n    </property>\r\n    <!--将异常信息存储到request域，value属性用来指定存储时的key。-->\r\n    <!--底层会执行这样的代码：request.setAttribute(\"e\", 异常对象)，这个异常对象SpringMVC会自己设置-->\r\n    <property name=\"exceptionAttribute\" value=\"e\"/>\r\n</bean>\r\n```\r\n\r\n配置拦截器：\r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <bean class=\"com.powernode.springmvc.interceptors.Interceptor1\"/>\r\n</mvc:interceptors>\r\n```\r\n\r\n或：\r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <ref bean=\"interceptor1\"/>\r\n</mvc:interceptors>\r\n```\r\n\r\n+ 需要添加包扫描\r\n+ 将拦截器使用@Component标注\r\n\r\n高级配置：\r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <mvc:interceptor>\r\n        <!--拦截所有路径-->\r\n        <mvc:mapping path=\"/**\"/>\r\n        <!--除 /test 路径之外，/test路径不拦截-->\r\n        <mvc:exclude-mapping path=\"/test\"/>\r\n        <!--设置拦截器-->\r\n        <ref bean=\"interceptor1\"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n# web.xml配置文件\r\n\r\n配置前端控制器：\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>dispatcherServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:springmvc.xml</param-value>\r\n    </init-param>\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>dispatcherServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n+ 表示当请求不是xx.jsp的时候，DispatcherServlet来负责处理本次请求\r\n\r\n配置静态资源默认Servlet：\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>default</servlet-name>\r\n    <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>debug</param-name>\r\n        <param-value>0</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>listings</param-name>\r\n        <param-value>false</param-value>\r\n    </init-param>\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>default</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n+ Tomcat自带的web.xml（CATALINA_HOME/conf/web.xml）有一个DefaultServlet可以用来处理静态资源，如果Tomcat没有自带，将一下代码手动写到自己的web.xml文件中也可以\r\n+ 或者使用springmvc.xml配置文件中的`<mvc:default-servlet-handler>` 或 `<mvc:resources>`\r\n\r\n配置字符编码过滤器：\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>characterEncodingFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n    <init-param>\r\n        <param-name>encoding</param-name>\r\n        <param-value>UTF-8</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>forceRequestEncoding</param-name>\r\n        <param-value>true</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>forceResponseEncoding</param-name>\r\n        <param-value>true</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>characterEncodingFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n配置文件下载：在DispatcherServlet的配置中添加一个属性\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>dispatcherServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:springmvc.xml</param-value>\r\n    </init-param>\r\n    <load-on-startup>1</load-on-startup>\r\n    <multipart-config>\r\n        <!--设置单个支持最大文件的大小-->\r\n        <max-file-size>102400</max-file-size>\r\n        <!--设置整个表单所有文件上传的最大值-->\r\n        <max-request-size>102400</max-request-size>\r\n        <!--设置最小上传文件大小-->\r\n        <file-size-threshold>0</file-size-threshold>\r\n    </multipart-config>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>dispatcherServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n', '2024/7/22 22:57:57', '2024/7/25 08:33:15', 0);
INSERT INTO `articles` VALUES (28, 'SSM整合', '记录了SSM整合的配置文件模板，和常规开发步骤', '/static/images/img1.png', 'edit', '# 引入依赖\r\n\r\n+ Spring：spring-jdbc\r\n+ Mybatis：mybatis、mybtais-spring、mysql-connector-java、druid\r\n+ SpringMVC：spring-web-mvc（包含了Spring的spring-context）、jakarta.servlet-api、thymeleaf-spring6、jackson-databind\r\n+ 日志依赖：logback-classic\r\n\r\n# 配置web.xml\r\n\r\n在src\\main下创建目录webapp，打开模块设置，添加web.xml文件，sping容器是在服务器启动的时候创建的，所以应该在web.xml中配置spring的配置文件：\r\n\r\n```xml\r\n<!--    配置Spring-->\r\n<listener>\r\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n</listener>\r\n<context-param>\r\n    <param-name>contextConfigLocation</param-name>\r\n    <param-value>classpath:spring.xml</param-value>\r\n</context-param>\r\n<!--    配置SpringMVC-->\r\n<servlet>\r\n    <servlet-name>dispatcherServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:springmvc.xml</param-value>\r\n    </init-param>\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>dispatcherServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n# 配置spring.xml\r\n\r\n配置包扫描、mybatis：\r\n\r\n```xml\r\n<!--包扫描-->\r\n<context:component-scan base-package=\"com.zsm\" />\r\n<!--    引入外部资源文件-->\r\n<context:property-placeholder location=\"jdbc.properties\" />\r\n<!--数据源-->\r\n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\r\n    <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\r\n    <property name=\"url\" value=\"${jdbc.url}\" />\r\n    <property name=\"username\" value=\"${jdbc.username}\" />\r\n    <property name=\"password\" value=\"${jdbc.password}\" />\r\n</bean>\r\n<!--配置mybatis-->\r\n<bean class=\"org.mybatis.spring.SqlSessionFactoryBean\" >\r\n    <property name=\"typeAliasesPackage\" value=\"com.zsm.bean\" />\r\n    <property name=\"dataSource\" ref=\"dataSource\" />\r\n</bean>\r\n<!--配置mapper扫描器-->\r\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\" >\r\n    <property name=\"basePackage\" value=\"com.zsm.mapper\" />\r\n</bean>\r\n```\r\n\r\n# 配置springmvc.xml\r\n\r\n配置包扫描、视图解析器、注解驱动：\r\n\r\n```xml\r\n<!--包扫描-->\r\n<context:component-scan base-package=\"com.zsm\" />\r\n<!--    配置视图解析器-->\r\n<bean id=\"thymeleafViewResolver\" class=\"org.thymeleaf.spring6.view.ThymeleafViewResolver\">\r\n    <property name=\"characterEncoding\" value=\"UTF-8\"/>\r\n    <property name=\"order\" value=\"1\"/>\r\n    <property name=\"templateEngine\">\r\n        <bean class=\"org.thymeleaf.spring6.SpringTemplateEngine\">\r\n            <property name=\"templateResolver\">\r\n                <bean class=\"org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver\">\r\n                    <property name=\"prefix\" value=\"/WEB-INF/templates/\"/>\r\n                    <property name=\"suffix\" value=\".html\"/>\r\n                    <property name=\"templateMode\" value=\"HTML\"/>\r\n                    <property name=\"characterEncoding\" value=\"UTF-8\"/>\r\n                </bean>\r\n            </property>\r\n        </bean>\r\n    </property>\r\n</bean>\r\n<!--    开启注解驱动-->\r\n<mvc:annotation-driven />\r\n<!--    处理静态资源默认servlet-->\r\n<mvc:default-servlet-handler/>\r\n```\r\n\r\n+ 访问根目录时跳转页面，所以配置视图解析器（也可以不用视图解析器）\r\n+ 开启注解驱动\r\n+ 需要使用到一些静态资源如js、css等，需要开启默认处理静态资源的servlet\r\n\r\n# 编写\r\n\r\n## 项目结构\r\n\r\n![image-20240628094333460](https://gitee.com/LowProfile666/image-bed/raw/master/img/202406280943559.png)\r\n\r\n## controller\r\n\r\n```java\r\n@Controller\r\npublic class UserController {\r\n    @Autowired\r\n    private UserService userService;\r\n    @GetMapping(\"/\")\r\n    public String index() {\r\n        return \"index\";\r\n    }\r\n\r\n    @GetMapping(\"list\")\r\n    @ResponseBody\r\n    public List<User> list() {\r\n        return userService.list();\r\n    }\r\n}\r\n```\r\n\r\n## mapper\r\n\r\nUserMapper.java:\r\n\r\n```java\r\npublic interface UserMapper {\r\n    List<User> list();\r\n}\r\n```\r\n\r\nUserMapper.xml:\r\n\r\n```xml\r\n<mapper namespace=\"com.zsm.mapper.UserMapper\">\r\n\r\n    <select id=\"list\" resultType=\"User\">\r\n        select * from user;\r\n    </select>\r\n</mapper>\r\n```\r\n\r\n## service\r\n\r\nUserService.java\r\n\r\n```java\r\npublic interface UserService {\r\n    List<User> list();\r\n}\r\n```\r\n\r\nUserServiceImpl.java:\r\n\r\n```java\r\n@Service(\"userService\")\r\npublic class UserServiceImpl implements UserService {\r\n    @Autowired\r\n    private UserMapper userMapper;\r\n    @Override\r\n    public List<User> list() {\r\n        return userMapper.list();\r\n    }\r\n}\r\n```\r\n\r\n## index.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>首页</title>\r\n    <link rel=\"stylesheet\" th:href=\"@{/static/css/bootstrap.min.css}\">\r\n    <script th:src=\"@{/static/js/jquery-3.7.1.min.js}\" ></script>\r\n    <script th:src=\"@{/static/js/bootstrap.min.js}\"></script>\r\n</head>\r\n<body>\r\n\r\n<div class=\"container\">\r\n    <script>\r\n        let url = [[@{/}]] + \"list\";\r\n        $.ajax({\r\n            url: url,\r\n            type: \"get\",\r\n            success(resp) {\r\n                console.log(resp);\r\n                resp.forEach(obj => {\r\n                    let html = `\r\n                        <div class=\"card\">\r\n                            <div class=\"card-body\">\r\n                                <div class=\"row\">\r\n                                    <div class=\"col\" id=\"username\">${obj.username}</div>\r\n                                    <div class=\"col\" id=\"password\">${obj.password}</div>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                    `;\r\n                    $(\".container\").append(html);\r\n                })\r\n            }\r\n        });\r\n    </script>\r\n</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n+ 引用了Thymeleaf，\r\n+ [[@{/}]]：获取项目的根路径\r\n\r\n![image-20240628094653229](https://gitee.com/LowProfile666/image-bed/raw/master/img/202406280946282.png)\r\n\r\n', '2024/7/22 17:30:12', NULL, 0);
INSERT INTO `articles` VALUES (36, '123333', '12333', '/upload/avatar7.jpg', 'note', '12', '2024/7/23 09:20:34', '2024/7/23 09:20:48', 1);
INSERT INTO `articles` VALUES (37, '', '', '/static/images/img1.png', 'note', '', '2024/7/23 09:35:17', NULL, 1);
INSERT INTO `articles` VALUES (38, '21', '123123', '/static/images/img1.png', 'note', '1231', '2024/7/23 09:36:50', '2024/7/23 09:37:13', 1);
INSERT INTO `articles` VALUES (39, 'nishuo', 'sdfsdf', '/upload/avatar2.jpg', 'project', 'sdfsdfsfd', '2024/7/23 10:18:25', '2024/7/23 10:18:52', 1);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `account` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', 'admin');

SET FOREIGN_KEY_CHECKS = 1;
